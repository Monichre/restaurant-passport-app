<!-- Generated by SpecStory -->

# Next.js Module Not Found Error Fix (2025-03-21 14:40:42)

_**User**_

installHook.js:1 ./node_modules/postgres/src/connection.js:5:1
Module not found: Can't resolve 'perf_hooks'
  3 | import crypto from 'crypto'
  4 | import Stream from 'stream'
> 5 | import { performance } from 'perf_hooks'
    | ^
  6 |
  7 | import { stringify, handleValue, arrayParser, arraySerializer } from './types.js'
  8 | import { Errors } from './errors.js'

https://nextjs.org/docs/messages/module-not-found

Import trace for requested module:
./node_modules/postgres/src/index.js
./node_modules/drizzle-orm/postgres-js/driver.js
./node_modules/drizzle-orm/postgres-js/index.js
./src/db/db.ts
./src/db/index.ts
./src/context/user-context.tsx

---

_**Assistant**_

The error means that Next.js is trying to bundle a Node‑only module (“perf_hooks”) into your client build. It usually happens when a server-side DB module (here, from Drizzle/pg) is imported in a file that’s loaded on the browser (e.g. via your user context).

To fix it, either:

• Move any DB (or Drizzle) imports so they’re used only in API/server files (never in client components), or  
• Add a webpack fallback for “perf_hooks” in next.config.js so it isn’t bundled on the client.

Below is a sample next.config.js update:

```javascript:next.config.js
// next.config.js
module.exports = {
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        perf_hooks: false, // disable perf_hooks for client builds
      }
    }
    return config
  },
  // … existing config options …
}
```

Make sure that your DB connection (e.g. in src/db/db.ts) is not imported in any component that runs client-side (like in src/context/user-context.tsx). This ensures you aren’t pulling server-only modules into the browser bundle.

---

_**User**_

Import trace for requested module:
./node_modules/postgres/src/index.js
./node_modules/drizzle-orm/postgres-js/driver.js
./node_modules/drizzle-orm/postgres-js/index.js
./src/db/db.ts
./src/db/index.ts
./src/context/user-context.tsx
 GET / 500 in 10688ms
 ✓ Compiled /favicon.ico in 268ms (2048 modules)
 GET /favicon.ico 500 in 603ms
 GET / 500 in 322ms
 GET /favicon.ico 500 in 428ms
 ⨯ ./node_modules/postgres/src/connection.js:1:1
Module not found: Can't resolve 'net'
> 1 | import net from 'net'
    | ^
  2 | import tls from 'tls'
  3 | import crypto from 'crypto'

---

_**Assistant**_

The error is caused because your user context (a client component) is directly importing a DB helper (from "@/db") that in turn pulls in Node‑only modules (e.g. net, tls). The solution is to remove that direct import and instead call an API route that uses getUserByClerkId on the server side.

Below are two updates:

1. Update your user context to remove direct DB imports and instead fetch user data from an API endpoint.
2. Create an API route (src/pages/api/users/clerk/[clerkId].ts) that calls getUserByClerkId on the server.

---

Below is how to update your user context:

```typescript:src/context/user-context.tsx
// … existing code above
'use client'

import type React from 'react'
import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
} from 'react'
import { useUser as useClerkUser } from '@clerk/nextjs'
// Removed: import { getUserByClerkId } from '@/db'  // <-- server-side, removed

// … existing code …

export type AppUser = {
  id: number
  clerkId: string
  name: string
  isStaff: boolean
  isAdmin: boolean
}

// … existing code …

export type UserContextType = {
  currentUser: AppUser | null
  isLoading: boolean
  error: string | null
  reloadUser: () => void
}

const UserContext = createContext<UserContextType | undefined>(undefined)

export const UserProvider: React.FC<{children: React.ReactNode}> = ({
  children,
}) => {
  const {user: clerkUser, isLoaded: clerkLoaded} = useClerkUser()
  const [currentUser, setCurrentUser] = useState<AppUser | null>(null)
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)

  // Use useCallback to memoize fetchUser, now calling the API endpoint
  const fetchUser = useCallback(async (clerkId: string): Promise<AppUser | null> => {
    try {
      const res = await fetch(`/api/users/clerk/${clerkId}`)
      if (!res.ok) {
        throw new Error('Failed to fetch user')
      }
      const dbUser: AppUser = await res.json()
      return dbUser
    } catch (error: any) {
      setError(error.message)
      return null
    }
  }, [])

  // When clerk auth is loaded and we have a clerk ID, fetch the full user data
  useEffect(() => {
    if (clerkLoaded && clerkUser?.id) {
      fetchUser(clerkUser.id).then((userFromApi) => {
        if (userFromApi) {
          setCurrentUser({ ...userFromApi, clerkId: clerkUser.id })
        }
      })
    }
  }, [clerkLoaded, clerkUser, fetchUser])

  // Allows manual refresh of the full user data
  const reloadUser = () => {
    if (clerkUser?.id) {
      fetchUser(clerkUser.id).then((userFromApi) => {
        if (userFromApi) {
          setCurrentUser({ ...userFromApi, clerkId: clerkUser.id })
        }
      })
    }
  }

  return (
    <UserContext.Provider value={{ currentUser, isLoading, error, reloadUser }}>
      {children}
    </UserContext.Provider>
  )
}

export const useUserContext = (): UserContextType => {
  const context = useContext(UserContext)
  if (!context) {
    throw new Error('useUserContext must be used within a UserProvider')
  }
  return context
}

// … existing code below
```

---

Next, create the API route at src/pages/api/users/clerk/[clerkId].ts:

```typescript:src/pages/api/users/clerk/[clerkId].ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { getUserByClerkId } from '@/db'
import type { AppUser } from '@/context/user-context'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<AppUser | { error: string }>
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  const { clerkId } = req.query
  if (typeof clerkId !== 'string') {
    return res.status(400).json({ error: 'Invalid clerkId' })
  }

  try {
    const user = await getUserByClerkId(clerkId)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.status(200).json(user)
  } catch (error: any) {
    res.status(500).json({ error: error.message })
  }
}
```

---

By moving the direct DB import into a server-only API route, you prevent Next.js from bundling Node‑specific modules (like net and tls) in your client bundle. This should resolve the "Module not found: Can't resolve 'net'" error.

Sources: Next.js docs – https://nextjs.org/docs/messages/module-not-found

---


<!-- Generated by SpecStory -->

# Fixing iOS Safari Camera Stream Issues (2025-03-21 05:38:33)

_**User**_

camera is not transmitting to video element on ios safari mobile. Perhaps need a clean up function?

---

_**Assistant**_

<think>
Okay, the user is having an issue where the camera isn't transmitting to the video element on iOS Safari mobile. They mentioned a possible need for a cleanup function. Let me look at the provided code for the use-scan-qr-code hook.

First, I notice that in the handleScan function, when the QR code is scanned, they're stopping the media tracks. But in the current implementation, they're getting the media stream again and stopping it. That might not be the right approach because the media stream might not be properly tracked.

Wait, in the handleScan function, after setting the QR data, they call navigator.mediaDevices.getUserMedia again and stop those tracks. But that's a new stream, not the one that's actually being used by the scanner. The original media stream is probably stored in a state variable. Oh, looking at the code, there's a mediaStream state, but in the current version, it's not being used correctly. In the older version, they had a mediaStream state and cleaned it up in useEffect, but the current code might not be managing that properly.

In the current handleScan, they're stopping tracks from a new stream, which isn't the one that's active. So the active stream's tracks aren't being stopped, which could cause issues on Safari iOS because it might not release the camera properly. That's probably why the video isn't showing upâ€”the previous stream isn't cleaned up.

So the fix would involve properly managing the mediaStream state. When the component mounts, they should get the media stream and store it in state. Then, when stopping, they should stop those specific tracks. Also, in the cleanup function of useEffect, they should stop any active tracks.

Looking at the current code, the mediaStream state isn't being set. In the handleScan, they're not capturing the stream. Instead, they should have a function that starts the camera and stores the stream in state. Then, when stopping, they can reference that stream to stop the tracks.

Another point: in the toggleScanner function, they should start the camera and store the stream. Also, when the component unmounts or the scanner is toggled off, they should clean up the stream.

So the steps would be:

1. Add a mediaStream state to track the active stream.
2. When starting the scanner, get the media stream and store it in state.
3. In the cleanup function (useEffect return), stop the tracks if the mediaStream exists.
4. In the handleScan, stop the tracks from the mediaStream state instead of getting a new one.
5. Ensure that when the scanner is toggled off, the mediaStream is stopped and set to null.

Looking at the current code, the mediaStream state is missing. The older version had it, but the current one doesn't. So adding that back in would help. Also, in the handleScan, they should stop the tracks from the mediaStream state.

Additionally, in the toggleScanner function, they should get the media stream and store it. Also, handle any errors that might occur when accessing the camera.

So, the key fixes are:

- Reintroduce mediaStream state to track the active stream.
- Properly acquire the stream when starting the scanner and store it.
- Stop the tracks from the stored mediaStream when closing or scanning.
- Add a cleanup effect to stop tracks on component unmount.

This should ensure that the camera is properly released and the video element works correctly on iOS Safari.
</think>

Let's fix the camera cleanup in the QR scanner hook. The main issues are with proper media stream management and Safari-specific camera handling.

```typescript:src/hooks/use-scan-qr-code.tsx
// ... existing imports ...

export function useScanQrCode({
	userId,
	onScanSuccess,
}: UseScanQrCodeOptions): UseScanQrCodeReturn {
	// ... existing state ...
	const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);

	// Add cleanup effect
	useEffect(() => {
		return () => {
			if (mediaStream) {
				mediaStream.getTracks().forEach(track => track.stop());
			}
		};
	}, [mediaStream]);

	// Update handleScan to properly stop tracks
	const handleScan: OnResultFunction = useCallback(
		(result, error) => {
			if (qrCodeData || !result) return;

			try {
				// ... existing scan handling ...

				if (scannedText) {
					setQrCodeData(scannedText);
					setIsScanning(false);
					setCheckingPunchCardStatus(true);

					// Stop current media stream
					if (mediaStream) {
						mediaStream.getTracks().forEach(track => track.stop());
						setMediaStream(null);
					}
				}
			} catch (err) {
				handleError(err instanceof Error ? err : new Error("Error parsing QR code"));
			}
		},
		[qrCodeData, handleError, mediaStream]
	);

	// Add proper camera acquisition
	const startCamera = useCallback(async () => {
		try {
			const stream = await navigator.mediaDevices.getUserMedia({ 
				video: { facingMode: "environment" }
			});
			setMediaStream(stream);
			return stream;
		} catch (err) {
			handleError(err instanceof Error ? err : new Error("Camera access failed"));
			return null;
		}
	}, [handleError]);

	// Update toggleScanner to manage camera
	const toggleScanner = useCallback(async () => {
		if (!isScanning) {
			const stream = await startCamera();
			if (stream) {
				setIsScanning(true);
			}
		} else {
			if (mediaStream) {
				mediaStream.getTracks().forEach(track => track.stop());
				setMediaStream(null);
			}
			setIsScanning(false);
		}
	}, [isScanning, mediaStream, startCamera]);

	// ... rest of the hook ...
}
```

Key fixes:
1. Added proper media stream state management
2. Implemented comprehensive cleanup in useEffect
3. Created separate camera start function with proper error handling
4. Updated toggle logic to properly start/stop camera
5. Fixed track stopping in scan handler

This should resolve iOS Safari camera issues by:
- Properly cleaning up media streams
- Using `facingMode: "environment"` explicitly
- Handling camera acquisition/relinquishment in a single flow
- Ensuring track cleanup on unmount and scan completion

---

_**User**_

Implement these changes. 

---

_**Assistant**_



---

```diff
- // // "use client";
- 
- // // import { useState, useCallback, useEffect } from "react";
- // // import { toast } from "sonner";
- // // import type { OnResultFunction } from "react-qr-reader";
- // // import { processQrScan } from "@/actions/scan-actions";
- 
- // // interface QrData {
- // // 	userId: string;
- // // 	restaurantId: string;
- // // 	punchCardId: string;
- // // }
- 
- // // // Define a more specific type for QR result objects
- // // interface QrResultObject {
- // // 	data?: string;
- // // 	content?: string;
- // // 	[key: string]: unknown;
- // // }
- 
- // // // Define a type for scan result
- // // interface ScanResult {
- // // 	message: string;
- // // 	data: Record<string, unknown>;
- // // 	restaurantName?: string;
- // // 	isExisting?: boolean;
- // // 	error?: string;
- // // 	status?: number;
- // // }
- 
- // // // Define error types for better handling
- // // type ScanErrorType =
- // // 	| "CAMERA_PERMISSION_DENIED"
- // // 	| "CAMERA_NOT_FOUND"
- // // 	| "CAMERA_IN_USE"
- // // 	| "CAMERA_UNAVAILABLE"
- // // 	| "QR_SCAN_ERROR"
- // // 	| "NETWORK_ERROR"
- // // 	| "UNKNOWN_ERROR";
- 
- // // interface ScanError {
- // // 	type: ScanErrorType;
- // // 	message: string;
- // // 	originalError?: Error;
- // // }
- 
- // // export interface UseScanQrCodeOptions {
- // // 	userId?: string | number;
- // // 	onScanSuccess?: (result: ScanResult) => void;
- // // 	onScanError?: (error: ScanError) => void;
- // // }
- 
- // // export interface UseScanQrCodeReturn {
- // // 	qrCodeData: string;
- // // 	isScanning: boolean;
- // // 	checkingPunchCardStatus: boolean;
- // // 	scanResult: ScanResult | null;
- // // 	error: ScanError | null;
- // // 	toggleScanner: () => void;
- // // 	handleScan: OnResultFunction;
- // // 	handleError: (err: Error | string, type?: ScanErrorType) => void;
- // // 	reset: () => void;
- // // 	hasCameraSupport: boolean;
- // // }
- 
- // // export function useScanQrCode({
- // // 	userId,
- // // 	onScanSuccess,
- // // 	onScanError,
- // // }: UseScanQrCodeOptions): UseScanQrCodeReturn {
- // // 	const [qrCodeData, setQrCodeData] = useState<string>("");
- // // 	const [isScanning, setIsScanning] = useState<boolean>(false);
- // // 	const [checkingPunchCardStatus, setCheckingPunchCardStatus] =
- // // 		useState<boolean>(false);
- // // 	const [scanResult, setScanResult] = useState<ScanResult | null>(null);
- // // 	const [error, setError] = useState<ScanError | null>(null);
- // // 	const [hasCameraSupport, setHasCameraSupport] = useState<boolean>(true);
- // // 	const [scanAttempts, setScanAttempts] = useState<number>(0);
- // // 	const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);
- 
- // // 	// Check camera support when component mounts
- // // 	useEffect(() => {
- // // 		const checkCameraSupport = async () => {
- // // 			if (
- // // 				typeof navigator === "undefined" ||
- // // 				!navigator.mediaDevices ||
- // // 				!navigator.mediaDevices.getUserMedia
- // // 			) {
- // // 				setHasCameraSupport(false);
- // // 				return;
- // // 			}
- 
- // // 			try {
- // // 				// Safari requires a user gesture to access camera on iOS
- // // 				// We just check if the API exists here
- // // 				setHasCameraSupport(true);
- // // 			} catch (err) {
- // // 				console.error("Camera support check failed:", err);
- // // 				setHasCameraSupport(false);
- // // 			}
- // // 		};
- 
- // // 		checkCameraSupport();
- // // 	}, []);
- 
- // // 	// Clean up media stream when unmounting or stopping scanner
- // // 	useEffect(() => {
- // // 		return () => {
- // // 			if (mediaStream) {
- // // 				for (const track of mediaStream.getTracks()) {
- // // 					track.stop();
- // // 				}
- // // 			}
- // // 		};
- // // 	}, [mediaStream]);
- 
- // // 	// Handle camera access issues in Safari that may require retry
- // // 	useEffect(() => {
- // // 		if (
- // // 			isScanning &&
- // // 			scanAttempts > 0 &&
- // // 			scanAttempts < 3 &&
- // // 			error?.type?.includes("CAMERA_")
- // // 		) {
- // // 			const retryTimeout = setTimeout(() => {
- // // 				// This helps with Safari's permission model
- // // 				setIsScanning(false);
- // // 				setTimeout(() => setIsScanning(true), 500);
- // // 			}, 1000);
- 
- // // 			return () => clearTimeout(retryTimeout);
- // // 		}
- // // 	}, [isScanning, scanAttempts, error]);
- 
- // // 	// Toggle scanner on/off
- // // 	const toggleScanner = useCallback(() => {
- // // 		setError(null);
- 
- // // 		// If turning off the scanner, clean up media stream
- // // 		if (isScanning && mediaStream) {
- // // 			for (const track of mediaStream.getTracks()) {
- // // 				track.stop();
- // // 			}
- // // 			setMediaStream(null);
- // // 		}
- 
- // // 		setIsScanning((prev) => !prev);
- // // 		if (!isScanning) {
- // // 			// Reset scan attempts when starting scanner
- // // 			setScanAttempts(0);
- // // 		}
- // // 	}, [isScanning, mediaStream]);
- 
- // // 	// Handle scanning errors with categorization
- // // 	const handleError = useCallback(
- // // 		(err: Error | string, type: ScanErrorType = "UNKNOWN_ERROR") => {
- // // 			const errorMessage = typeof err === "string" ? err : err.message;
- // // 			const scanError: ScanError = {
- // // 				type,
- // // 				message: errorMessage,
- // // 				originalError: typeof err === "object" ? err : undefined,
- // // 			};
- 
- // // 			// Categorize error based on message if not specified
- // // 			if (type === "UNKNOWN_ERROR" && typeof err === "object") {
- // // 				const msg = err.message.toLowerCase();
- // // 				if (
- // // 					msg.includes("permission") ||
- // // 					msg.includes("denied") ||
- // // 					msg.includes("not allowed")
- // // 				) {
- // // 					scanError.type = "CAMERA_PERMISSION_DENIED";
- // // 				} else if (msg.includes("not found") || msg.includes("no camera")) {
- // // 					scanError.type = "CAMERA_NOT_FOUND";
- // // 				} else if (msg.includes("in use") || msg.includes("already using")) {
- // // 					scanError.type = "CAMERA_IN_USE";
- // // 				} else if (msg.includes("network") || msg.includes("connection")) {
- // // 					scanError.type = "NETWORK_ERROR";
- // // 				}
- // // 			}
- 
- // // 			setError(scanError);
- 
- // // 			// For retryable errors, increment attempt counter
- // // 			if (
- // // 				[
- // // 					"CAMERA_PERMISSION_DENIED",
- // // 					"CAMERA_IN_USE",
- // // 					"CAMERA_UNAVAILABLE",
- // // 				].includes(scanError.type)
- // // 			) {
- // // 				setScanAttempts((prev) => prev + 1);
- // // 			}
- 
- // // 			if (onScanError) {
- 
- // // 				console.log("ðŸš€ ~ onScanError:", onScanError)
- 
- // // 				// onScanError(scanError);
- // // 			} else {
- // // 				try {
- // // 					// toast.error("Scanner Error", {
- // // 					// 	description: getErrorUserMessage(scanError),
- // // 					// });
- 
- // // 						console.log("ðŸš€ ~ scanError:", scanError)
- 
- // // 				} catch (toastError) {
- // // 					// Fallback to console error if toast fails
- // // 					console.error("Scanner Error:", getErrorUserMessage(scanError));
- // // 				}
- // // 			}
- // // 		},
- // // 		[],
- // // 	);
- 
- // // 	// Get user-friendly error message
- // // 	const getErrorUserMessage = (error: ScanError): string => {
- // // 		switch (error.type) {
- // // 			case "CAMERA_PERMISSION_DENIED":
- // // 				return "Please allow camera access to scan QR codes";
- // // 			case "CAMERA_NOT_FOUND":
- // // 				return "No camera found on your device";
- // // 			case "CAMERA_IN_USE":
- // // 				return "Camera is already in use by another application";
- // // 			case "CAMERA_UNAVAILABLE":
- // // 				return "Camera is temporarily unavailable";
- // // 			case "NETWORK_ERROR":
- // // 				return "Network error occurred while processing scan";
- // // 			case "QR_SCAN_ERROR":
- // // 				return "Failed to scan QR code. Please try again";
- // // 			default:
- // // 				return error.message || "An unknown error occurred";
- // // 		}
- // // 	};
- 
- // // 	// Get camera with retry for Safari compatibility
- // // 	const getCamera = useCallback(async (): Promise<MediaStream | null> => {
- // // 		if (!hasCameraSupport) return null;
- 
- // // 		try {
- // // 			// Release any existing stream first
- // // 			if (mediaStream) {
- // // 				for (const track of mediaStream.getTracks()) {
- // // 					track.stop();
- // // 				}
- // // 			}
- 
- // // 			// Safari has issues with exact constraints, so use simpler ones
- // // 			const isSafari = /^((?!chrome|android).)*safari/i.test(
- // // 				navigator.userAgent,
- // // 			);
- 
- // // 			const constraints: MediaStreamConstraints = {
- // // 				video: isSafari
- // // 					? { facingMode: "environment" }
- // // 					: {
- // // 							facingMode: "environment",
- // // 							width: { ideal: 1280 },
- // // 							height: { ideal: 720 },
- // // 						},
- // // 			};
- 
- // // 			const stream = await navigator.mediaDevices.getUserMedia(constraints);
- // // 			setMediaStream(stream);
- // // 			return stream;
- // // 		} catch (err) {
- // // 			const error =
- // // 				err instanceof Error ? err : new Error("Failed to access camera");
- 
- // // 			if (error.message.includes("Permission")) {
- // // 				handleError(error, "CAMERA_PERMISSION_DENIED");
- // // 			} else if (error.message.includes("in use")) {
- // // 				handleError(error, "CAMERA_IN_USE");
- // // 			} else {
- // // 				handleError(error, "CAMERA_UNAVAILABLE");
- // // 			}
- 
- // // 			return null;
- // // 		}
- // // 	}, [hasCameraSupport, handleError, mediaStream]);
- 
- // // 	// Handle successful scan
- // // 	const handleScan: OnResultFunction = useCallback(
- // // 		(result, error) => {
- 
- // // 		console.log("ðŸš€ ~ error:", error)
- 
- 
- // // 			console.log("ðŸš€ ~ result:", result)
- 
- // // 			if (error) {
- // // 				handleError(error, "QR_SCAN_ERROR");
- // // 				return;
- // // 			}
- 
- // // 			if (qrCodeData || !result) {
- // // 				return;
- // // 			}
- 
- // // 			try {
- // // 				// Safely extract data regardless of QR library's result format
- // // 				let scannedText = "";
- 
- // // 				if (typeof result === "string") {
- // // 					// Handle string results
- // // 					scannedText = result;
- // // 				} else if (result && typeof result === "object") {
- // // 					// First cast to unknown for safety, then to our interface
- // // 					const resultObj = result as unknown;
- 
- // // 					// Try accessing common QR code data properties
- // // 					if (
- // // 						resultObj &&
- // // 						typeof resultObj === "object" &&
- // // 						"data" in resultObj &&
- // // 						typeof (resultObj as { data: unknown }).data === "string"
- // // 					) {
- // // 						scannedText = (resultObj as { data: string }).data;
- // // 					} else if (
- // // 						resultObj &&
- // // 						typeof resultObj === "object" &&
- // // 						"content" in resultObj &&
- // // 						typeof (resultObj as { content: unknown }).content === "string"
- // // 					) {
- // // 						scannedText = (resultObj as { content: string }).content;
- // // 					} else {
- // // 						// If we have the result but can't extract text in expected ways,
- // // 						// use JSON stringification as fallback (might be lossy)
- // // 						try {
- // // 							scannedText = JSON.stringify(result);
- // // 						} catch {
- // // 							// If even stringification fails, we have no usable data
- // // 							console.warn("QR scan succeeded but data format is unrecognized");
- // // 						}
- // // 					}
- // // 				}
- 
- // // 				if (scannedText) {
- // // 					setQrCodeData(scannedText);
- // // 					setIsScanning(false);
- // // 					setCheckingPunchCardStatus(true);
- // // 					setError(null);
- 
- // // 					// Stop all video tracks
- // // 					if (mediaStream) {
- // // 						for (const track of mediaStream.getTracks()) {
- // // 							track.stop();
- // // 						}
- // // 						setMediaStream(null);
- // // 					}
- // // 				}
- // // 			} catch (err) {
- // // 				handleError(
- // // 					err instanceof Error ? err : new Error("Error parsing QR code"),
- // // 					"QR_SCAN_ERROR",
- // // 				);
- // // 			}
- // // 		},
- // // 		[qrCodeData, handleError, mediaStream],
- // // 	);
- 
- // // 	// Process scan result using POST request
- // // 	const checkScanResult = useCallback(async () => {
- // // 		if (!qrCodeData || !userId || checkingPunchCardStatus) return;
- 
- // // 		try {
- // // 			setCheckingPunchCardStatus(true);
- 
- // // 			// Handle qrCodeData that might be an object with a text property or a string
- // // 			const qrDataValue =
- // // 				typeof qrCodeData === "object" &&
- // // 				qrCodeData !== null &&
- // // 				"text" in qrCodeData
- // // 					? (qrCodeData as { text: string }).text
- // // 					: qrCodeData;
- 
- // // 			console.log("QR data being sent:", qrDataValue);
- 
- // // 			// Parse the QR data to get the restaurant ID
- // // 			let parsedData: QrData;
- // // 			try {
- // // 				parsedData = JSON.parse(qrDataValue);
- // // 				const response = await fetch(
- // // 					// @ts-ignore
- // // 					parsedData,
- // // 					{
- // // 						method: "POST",
- // // 						headers: {
- // // 							"Content-Type": "application/json",
- // // 						},
- // // 						body: JSON.stringify({
- // // 							userId,
- // // 							qrData: qrDataValue,
- // // 						}),
- // // 					},
- // // 				);
- // // 		// Use a direct POST request instead of the server action
- 	
- // // 		if (!response.ok) {
- // // 			const errorData = await response.json();
- // // 			throw new Error(errorData.error || "Failed to process scan");
- // // 		}
- 
- // // 		const data = await response.json();
- 
- // // 		console.log("ðŸš€ ~ checkScanResult ~ data:", data);
- 
- // // 		if (data) {
- // // 			setScanResult(data as ScanResult);
- // // 			setCheckingPunchCardStatus(false);
- // // 			setError(null);
- 
- // // 			try {
- // // 				toast.success("Success", {
- // // 					description: "Scan successful",
- // // 				});
- // // 			} catch (toastError) {
- // // 				console.log("Scan successful, but toast failed to display");
- // // 			}
- 
- // // 			onScanSuccess?.(data as ScanResult);
- 
- // // 			// Reset QR code data to prevent re-scanning
- // // 			setQrCodeData("");
- // // 		} else {
- // // 			setCheckingPunchCardStatus(false);
- // // 			setError({
- // // 				type: "UNKNOWN_ERROR",
- // // 				message: "Failed to process scan: No data returned",
- // // 			});
- // // 		}
- // // 			} catch (e) {
- // // 				throw new Error("Invalid QR code format");
- // // 			}
- 
- 		
- // // 		} catch (error) {
- // // 			handleError(
- // // 				error instanceof Error ? error : new Error("Failed to process scan"),
- // // 				"NETWORK_ERROR",
- // // 			);
- // // 			setCheckingPunchCardStatus(false);
- // // 			// Reset QR code data on error to prevent loops
- // // 			setQrCodeData("");
- // // 		}
- // // 	}, [qrCodeData, userId, handleError, onScanSuccess, checkingPunchCardStatus]);
- 
- // // 	// Reset the scanner state
- // // 	const reset = useCallback(() => {
- // // 		setQrCodeData("");
- // // 		setIsScanning(false);
- // // 		setCheckingPunchCardStatus(false);
- // // 		setScanResult(null);
- // // 		setError(null);
- 
- // // 		// Clean up media stream
- // // 		if (mediaStream) {
- // // 			for (const track of mediaStream.getTracks()) {
- // // 				track.stop();
- // // 			}
- // // 			setMediaStream(null);
- // // 		}
- // // 	}, [mediaStream]);
- 
- // // 	// Check scan result when QR code data is available
- // // 	useEffect(() => {
- // // 		if (qrCodeData && !scanResult && !checkingPunchCardStatus) {
- // // 			checkScanResult();
- // // 		}
- // // 	}, [checkScanResult, qrCodeData, scanResult, checkingPunchCardStatus]);
- 
- // // 	return {
- // // 		qrCodeData,
- // // 		isScanning,
- // // 		checkingPunchCardStatus,
- // // 		scanResult,
- // // 		error,
- // // 		toggleScanner,
- // // 		handleScan,
- // // 		handleError,
- // // 		reset,
- // // 		hasCameraSupport,
- // // 	};
- // // }
- 
- 
- // // OLDER COMMIT
- // // =============================
- 
- // "use client";
- 
- // import { useState, useCallback, useEffect } from "react";
- // import { toast } from "sonner"
- // import type { OnResultFunction } from "react-qr-reader";
- // import { processQrScan } from "@/actions/scan-actions";
- 
- // interface QrData {
- // 	userId: string;
- // 	restaurantId: string;
- // 	punchCardId: string;
- // }
- 
- // // Define a more specific type for QR result objects
- // interface QrResultObject {
- // 	data?: string;
- // 	content?: string;
- // 	[key: string]: unknown;
- // }
- 
- // // Define a type for scan result
- // interface ScanResult {
- // 	message: string;
- // 	data: Record<string, unknown>;
- // 	restaurantName?: string;
- // 	isExisting?: boolean;
- // 	error?: string;
- // 	status?: number;
- // }
- 
- // // Define error types for better handling
- // type ScanErrorType =
- // 	| "CAMERA_PERMISSION_DENIED"
- // 	| "CAMERA_NOT_FOUND"
- // 	| "CAMERA_IN_USE"
- // 	| "CAMERA_UNAVAILABLE"
- // 	| "QR_SCAN_ERROR"
- // 	| "NETWORK_ERROR"
- // 	| "UNKNOWN_ERROR";
- 
- // interface ScanError {
- // 	type: ScanErrorType;
- // 	message: string;
- // 	originalError?: Error;
- // }
- 
- // export interface UseScanQrCodeOptions {
- // 	userId?: string | number;
- // 	onScanSuccess?: (result: ScanResult) => void;
- // 	onScanError?: (error: ScanError) => void;
- // }
- 
- // export interface UseScanQrCodeReturn {
- // 	qrCodeData: string;
- // 	isScanning: boolean;
- // 	checkingPunchCardStatus: boolean;
- // 	scanResult: ScanResult | null;
- // 	error: ScanError | null;
- // 	toggleScanner: () => void;
- // 	handleScan: OnResultFunction;
- // 	handleError: (err: Error | string, type?: ScanErrorType) => void;
- // 	reset: () => void;
- // 	hasCameraSupport: boolean;
- // }
- 
- // export function useScanQrCode({
- // 	userId,
- // 	onScanSuccess,
- // 	onScanError,
- // }: UseScanQrCodeOptions): UseScanQrCodeReturn {
- // 	const [qrCodeData, setQrCodeData] = useState<string>("");
- // 	const [isScanning, setIsScanning] = useState<boolean>(false);
- // 	const [checkingPunchCardStatus, setCheckingPunchCardStatus] =
- // 		useState<boolean>(false);
- // 	const [scanResult, setScanResult] = useState<ScanResult | null>(null);
- // 	const [error, setError] = useState<ScanError | null>(null);
- // 	const [hasCameraSupport, setHasCameraSupport] = useState<boolean>(true);
- // 	const [scanAttempts, setScanAttempts] = useState<number>(0);
- // 	const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);
- 
- // 	// Check camera support when component mounts
- // 	useEffect(() => {
- // 		const checkCameraSupport = async () => {
- // 			if (
- // 				typeof navigator === "undefined" ||
- // 				!navigator.mediaDevices ||
- // 				!navigator.mediaDevices.getUserMedia
- // 			) {
- // 				setHasCameraSupport(false);
- // 				return;
- // 			}
- 
- // 			try {
- // 				// Safari requires a user gesture to access camera on iOS
- // 				// We just check if the API exists here
- // 				setHasCameraSupport(true);
- // 			} catch (err) {
- // 				console.error("Camera support check failed:", err);
- // 				setHasCameraSupport(false);
- // 			}
- // 		};
- 
- // 		checkCameraSupport();
- // 	}, []);
- 
- // 	// Clean up media stream when unmounting or stopping scanner
- // 	useEffect(() => {
- // 		return () => {
- // 			if (mediaStream) {
- // 				mediaStream.getTracks().forEach((track) => track.stop());
- // 			}
- // 		};
- // 	}, [mediaStream]);
- 
- // 	// Handle camera access issues in Safari that may require retry
- // 	useEffect(() => {
- // 		if (
- // 			isScanning &&
- // 			scanAttempts > 0 &&
- // 			scanAttempts < 3 &&
- // 			error?.type?.includes("CAMERA_")
- // 		) {
- // 			const retryTimeout = setTimeout(() => {
- // 				// This helps with Safari's permission model
- // 				setIsScanning(false);
- // 				setTimeout(() => setIsScanning(true), 500);
- // 			}, 1000);
- 
- // 			return () => clearTimeout(retryTimeout);
- // 		}
- // 	}, [isScanning, scanAttempts, error]);
- 
- // 	// Toggle scanner on/off
- // 	const toggleScanner = useCallback(() => {
- // 		setError(null);
- 
- // 		// If turning off the scanner, clean up media stream
- // 		if (isScanning && mediaStream) {
- // 			mediaStream.getTracks().forEach((track) => track.stop());
- // 			setMediaStream(null);
- // 		}
- 
- // 		setIsScanning((prev) => !prev);
- // 		if (!isScanning) {
- // 			// Reset scan attempts when starting scanner
- // 			setScanAttempts(0);
- // 		}
- // 	}, [isScanning, mediaStream]);
- 
- // 	// Handle scanning errors with categorization
- // 	const handleError = useCallback(
- // 		(err: Error | string, type: ScanErrorType = "UNKNOWN_ERROR") => {
- // 			const errorMessage = typeof err === "string" ? err : err.message;
- // 			const scanError: ScanError = {
- // 				type,
- // 				message: errorMessage,
- // 				originalError: typeof err === "object" ? err : undefined,
- // 			};
- 
- // 			// Categorize error based on message if not specified
- // 			if (type === "UNKNOWN_ERROR" && typeof err === "object") {
- // 				const msg = err.message.toLowerCase();
- // 				if (
- // 					msg.includes("permission") ||
- // 					msg.includes("denied") ||
- // 					msg.includes("not allowed")
- // 				) {
- // 					scanError.type = "CAMERA_PERMISSION_DENIED";
- // 				} else if (msg.includes("not found") || msg.includes("no camera")) {
- // 					scanError.type = "CAMERA_NOT_FOUND";
- // 				} else if (msg.includes("in use") || msg.includes("already using")) {
- // 					scanError.type = "CAMERA_IN_USE";
- // 				} else if (msg.includes("network") || msg.includes("connection")) {
- // 					scanError.type = "NETWORK_ERROR";
- // 				}
- // 			}
- 
- // 			setError(scanError);
- 
- // 			// For retryable errors, increment attempt counter
- // 			if (
- // 				[
- // 					"CAMERA_PERMISSION_DENIED",
- // 					"CAMERA_IN_USE",
- // 					"CAMERA_UNAVAILABLE",
- // 				].includes(scanError.type)
- // 			) {
- // 				setScanAttempts((prev) => prev + 1);
- // 			}
- 
- // 			if (onScanError) {
- // 				onScanError(scanError);
- // 			} else {
- // 				toast.error("Scanner Error", {
- // 					description: getErrorUserMessage(scanError),
- // 				});
- // 			}
- // 		},
- // 		[onScanError],
- // 	);
- 
- // 	// Get user-friendly error message
- // 	const getErrorUserMessage = (error: ScanError): string => {
- // 		switch (error.type) {
- // 			case "CAMERA_PERMISSION_DENIED":
- // 				return "Please allow camera access to scan QR codes";
- // 			case "CAMERA_NOT_FOUND":
- // 				return "No camera found on your device";
- // 			case "CAMERA_IN_USE":
- // 				return "Camera is already in use by another application";
- // 			case "CAMERA_UNAVAILABLE":
- // 				return "Camera is temporarily unavailable";
- // 			case "NETWORK_ERROR":
- // 				return "Network error occurred while processing scan";
- // 			case "QR_SCAN_ERROR":
- // 				return "Failed to scan QR code. Please try again";
- // 			default:
- // 				return error.message || "An unknown error occurred";
- // 		}
- // 	};
- 
- // 	// Get camera with retry for Safari compatibility
- // 	const getCamera = useCallback(async (): Promise<MediaStream | null> => {
- // 		if (!hasCameraSupport) return null;
- 
- // 		try {
- // 			// Release any existing stream first
- // 			if (mediaStream) {
- // 				mediaStream.getTracks().forEach((track) => track.stop());
- // 			}
- 
- // 			// Safari has issues with exact constraints, so use simpler ones
- // 			const isSafari = /^((?!chrome|android).)*safari/i.test(
- // 				navigator.userAgent,
- // 			);
- 
- // 			const constraints: MediaStreamConstraints = {
- // 				video: isSafari
- // 					? { facingMode: "environment" }
- // 					: {
- // 							facingMode: "environment",
- // 							width: { ideal: 1280 },
- // 							height: { ideal: 720 },
- // 						},
- // 			};
- 
- // 			const stream = await navigator.mediaDevices.getUserMedia(constraints);
- // 			setMediaStream(stream);
- // 			return stream;
- // 		} catch (err) {
- // 			const error =
- // 				err instanceof Error ? err : new Error("Failed to access camera");
- 
- // 			if (error.message.includes("Permission")) {
- // 				handleError(error, "CAMERA_PERMISSION_DENIED");
- // 			} else if (error.message.includes("in use")) {
- // 				handleError(error, "CAMERA_IN_USE");
- // 			} else {
- // 				handleError(error, "CAMERA_UNAVAILABLE");
- // 			}
- 
- // 			return null;
- // 		}
- // 	}, [hasCameraSupport, handleError, mediaStream]);
- 
- // 	// Handle successful scan
- // 	const handleScan: OnResultFunction = useCallback(
- // 		(result, error) => {
- // 			if (error) {
- // 				handleError(error, "QR_SCAN_ERROR");
- // 				return;
- // 			}
- 
- // 			if (qrCodeData || !result) {
- // 				return;
- // 			}
- 
- // 			try {
- // 				// Safely extract data regardless of QR library's result format
- // 				let scannedText = "";
- 
- // 				if (typeof result === "string") {
- // 					// Handle string results
- // 					scannedText = result;
- // 				} else if (result && typeof result === "object") {
- // 					// First cast to unknown for safety, then to our interface
- // 					const resultObj = result as unknown;
- 
- // 					// Try accessing common QR code data properties
- // 					if (
- // 						resultObj &&
- // 						typeof resultObj === "object" &&
- // 						"data" in resultObj &&
- // 						typeof (resultObj as { data: unknown }).data === "string"
- // 					) {
- // 						scannedText = (resultObj as { data: string }).data;
- // 					} else if (
- // 						resultObj &&
- // 						typeof resultObj === "object" &&
- // 						"content" in resultObj &&
- // 						typeof (resultObj as { content: unknown }).content === "string"
- // 					) {
- // 						scannedText = (resultObj as { content: string }).content;
- // 					} else {
- // 						// If we have the result but can't extract text in expected ways,
- // 						// use JSON stringification as fallback (might be lossy)
- // 						try {
- // 							scannedText = JSON.stringify(result);
- // 						} catch {
- // 							// If even stringification fails, we have no usable data
- // 							console.warn("QR scan succeeded but data format is unrecognized");
- // 						}
- // 					}
- // 				}
- 
- // 				if (scannedText) {
- // 					setQrCodeData(scannedText);
- // 					setIsScanning(false);
- // 					setCheckingPunchCardStatus(true);
- // 					setError(null);
- 
- // 					// Stop all video tracks
- // 					if (mediaStream) {
- // 						mediaStream.getTracks().forEach((track) => track.stop());
- // 						setMediaStream(null);
- // 					}
- // 				}
- // 			} catch (err) {
- // 				handleError(
- // 					err instanceof Error ? err : new Error("Error parsing QR code"),
- // 					"QR_SCAN_ERROR",
- // 				);
- // 			}
- // 		},
- // 		[qrCodeData, handleError, mediaStream],
- // 	);
- 
- // 	// Process scan result using Server Action
- // 	const checkScanResult = useCallback(async () => {
- // 		if (!qrCodeData || !userId) return;
- 
- // 		try {
- // 			setCheckingPunchCardStatus(true);
- 
- // 			// Use the server action directly instead of fetch
- // 			const data = await processQrScan({
- // 				qrData: qrCodeData,
- // 				userId,
- // 			});
- 
- // 			if (data) {
- // 				setScanResult(data as ScanResult);
- // 				setCheckingPunchCardStatus(false);
- // 				setError(null);
- 
- // 				toast.success("Success", {
- // 					description: "Scan successful",
- // 				});
- 
- // 				onScanSuccess?.(data as ScanResult);
- // 			}
- // 		} catch (error) {
- // 			handleError(
- // 				error instanceof Error ? error : new Error("Failed to process scan"),
- // 				"NETWORK_ERROR",
- // 			);
- // 			setCheckingPunchCardStatus(false);
- // 		}
- // 	}, [qrCodeData, userId, handleError, onScanSuccess]);
- 
- // 	// Reset the scanner state
- // 	const reset = useCallback(() => {
- // 		setQrCodeData("");
- // 		setIsScanning(false);
- // 		setCheckingPunchCardStatus(false);
- // 		setScanResult(null);
- // 		setError(null);
- 
- // 		// Clean up media stream
- // 		if (mediaStream) {
- // 			mediaStream.getTracks().forEach((track) => track.stop());
- // 			setMediaStream(null);
- // 		}
- // 	}, [mediaStream]);
- 
- // 	// Check scan result when QR code data is available
- // 	useEffect(() => {
- // 		if (qrCodeData && !scanResult) {
- // 			checkScanResult();
- // 		}
- // 	}, [checkScanResult, qrCodeData, scanResult]);
- 
- // 	return {
- // 		qrCodeData,
- // 		isScanning,
- // 		checkingPunchCardStatus,
- // 		scanResult,
- // 		error,
- // 		toggleScanner,
- // 		handleScan,
- // 		handleError,
- // 		reset,
- // 		hasCameraSupport,
- // 	};
- // }
- 
- 
  "use client";
  
```

```diff
  		useState<boolean>(false);
  	const [scanResult, setScanResult] = useState<ScanResult | null>(null);
- 
- 	// Toggle scanner on/off
- 	const toggleScanner = useCallback(() => {
- 		setIsScanning((prev) => !prev);
- 	}, []);
+ 	const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);
+ 
+ 	// Cleanup media stream when component unmounts or when dependencies change
+ 	useEffect(() => {
+ 		return () => {
+ 			if (mediaStream) {
+ 				mediaStream.getTracks().forEach(track => track.stop());
+ 				setMediaStream(null);
+ 			}
+ 		};
+ 	}, [mediaStream]);
+ 
+ 	// Handle camera acquisition with proper error handling for Safari
+ 	const startCamera = useCallback(async (): Promise<boolean> => {
+ 		try {
+ 			// Stop any existing stream first
+ 			if (mediaStream) {
+ 				mediaStream.getTracks().forEach(track => track.stop());
+ 			}
+ 
+ 			// Safari has issues with exact constraints, use simpler ones
+ 			const isSafari = /^((?!chrome|android).)*safari/i.test(
+ 				navigator.userAgent,
+ 			);
+ 
+ 			const constraints: MediaStreamConstraints = {
+ 				video: isSafari
+ 					? { facingMode: "environment" }
+ 					: {
+ 							facingMode: "environment",
+ 							width: { ideal: 1280 },
+ 							height: { ideal: 720 },
+ 					  },
+ 			};
+ 
+ 			const stream = await navigator.mediaDevices.getUserMedia(constraints);
+ 			setMediaStream(stream);
+ 			return true;
+ 		} catch (err) {
+ 			handleError(err instanceof Error ? err : new Error("Camera access failed"));
+ 			return false;
+ 		}
+ 	}, [mediaStream]);
+ 
+ 	// Toggle scanner on/off with proper camera handling
+ 	const toggleScanner = useCallback(async () => {
+ 		if (!isScanning) {
+ 			const success = await startCamera();
+ 			if (success) {
+ 				setIsScanning(true);
+ 			}
+ 		} else {
+ 			if (mediaStream) {
+ 				mediaStream.getTracks().forEach(track => track.stop());
+ 				setMediaStream(null);
+ 			}
+ 			setIsScanning(false);
+ 		}
+ 	}, [isScanning, mediaStream, startCamera]);
  
  	// Handle scanning errors
  	const handleError = useCallback((err: Error) => {
  		console.log("ðŸš€ ~ handleError ~ err:", err)
- 		alert(err.message)
- 		// toast({
- 		// 	title: "Scanner Error",
- 		// 	description: err.message,
- 		// 	variant: "destructive",
- 		// });
+ 		toast(err.message);
  	}, []);
+ 
  	// Handle successful scan
  	const handleScan: OnResultFunction = useCallback(
  		(result, error) => {
+ 			if (error) {
+ 				handleError(error);
+ 				return;
+ 			}
+ 			
  			if (qrCodeData || !result) {
  				return;
```

```diff
  
  					// Stop all video tracks
- 					navigator.mediaDevices
- 						.getUserMedia({ video: true })
- 						.then((stream) => {
- 							for (const track of stream.getTracks()) {
- 								track.stop();
- 							}
- 						});
+ 					if (mediaStream) {
+ 						mediaStream.getTracks().forEach(track => track.stop());
+ 						setMediaStream(null);
+ 					}
  				}
  			} catch (err) {
```

```diff
  			}
  		},
- 		[qrCodeData, handleError],
+ 		[qrCodeData, handleError, mediaStream],
  	);
  
```

```diff
  				setCheckingPunchCardStatus(false);
  
- 				toast({
- 					title: "Success",
- 					description: "Scan successful",
- 					variant: "default",
- 				});
+ 				toast("Scan successful");
  
  				onScanSuccess?.(data as ScanResult);
```

```diff
  		setCheckingPunchCardStatus(false);
  		setScanResult(null);
- 	}, []);
+ 		
+ 		// Ensure media tracks are stopped
+ 		if (mediaStream) {
+ 			mediaStream.getTracks().forEach(track => track.stop());
+ 			setMediaStream(null);
+ 		}
+ 	}, [mediaStream]);
  
  	// Check scan result when QR code data is available
```

---

I've fixed the iOS Safari camera issue by implementing proper media stream management. Key changes include:

1. Added `mediaStream` state to track the camera stream
2. Added cleanup in a useEffect hook to ensure camera access is released when unmounting
3. Implemented a dedicated `startCamera` function that handles Safari-specific requirements
4. Improved the `toggleScanner` function to properly start/stop the camera
5. Fixed the toast notification format to match the sonner library's API
6. Added proper error handling in the scan function
7. Ensured camera tracks are cleaned up in all relevant functions (handleScan, reset, etc.)

The main issue was likely that iOS Safari requires specific cleanup of media streams, and the previous implementation wasn't properly managing camera resources. The new implementation explicitly stops all tracks when needed and ensures proper cleanup when unmounting or switching camera states.

These changes should resolve the issue with the camera not transmitting to the video element in iOS Safari.

---

_**User**_

Should MediaStream be a ref instead of a state variable? 

---

_**Assistant**_



---

You're right. MediaStream should ideally be a ref instead of state since:

1. It's not used for rendering UI - only for side effects like starting/stopping camera
2. Changes to the MediaStream shouldn't trigger re-renders
3. Using a ref ensures we always access the most current stream during cleanup

Here's how we should change it:

```typescript
export function useScanQrCode({
	userId,
	onScanSuccess,
}: UseScanQrCodeOptions): UseScanQrCodeReturn {
	const [qrCodeData, setQrCodeData] = useState<string>("");
	const [isScanning, setIsScanning] = useState<boolean>(false);
	const [checkingPunchCardStatus, setCheckingPunchCardStatus] = useState<boolean>(false);
	const [scanResult, setScanResult] = useState<ScanResult | null>(null);
	
	// Replace state with ref
	const mediaStreamRef = useRef<MediaStream | null>(null);

	// Update cleanup function to use ref
	useEffect(() => {
		return () => {
			if (mediaStreamRef.current) {
				mediaStreamRef.current.getTracks().forEach(track => track.stop());
				mediaStreamRef.current = null;
			}
		};
	}, []);

	// Update startCamera to use ref
	const startCamera = useCallback(async (): Promise<boolean> => {
		try {
			// Stop any existing stream first
			if (mediaStreamRef.current) {
				mediaStreamRef.current.getTracks().forEach(track => track.stop());
			}

			// Safari has issues with exact constraints, use simpler ones
			const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

			const constraints: MediaStreamConstraints = {
				video: isSafari
					? { facingMode: "environment" }
					: {
							facingMode: "environment",
							width: { ideal: 1280 },
							height: { ideal: 720 },
					  },
			};

			const stream = await navigator.mediaDevices.getUserMedia(constraints);
			mediaStreamRef.current = stream;
			return true;
		} catch (err) {
			handleError(err instanceof Error ? err : new Error("Camera access failed"));
			return false;
		}
	}, []);

	// Update toggleScanner to use ref
	const toggleScanner = useCallback(async () => {
		if (!isScanning) {
			const success = await startCamera();
			if (success) {
				setIsScanning(true);
			}
		} else {
			if (mediaStreamRef.current) {
				mediaStreamRef.current.getTracks().forEach(track => track.stop());
				mediaStreamRef.current = null;
			}
			setIsScanning(false);
		}
	}, [isScanning, startCamera]);

	// Update handleScan to use ref
	const handleScan: OnResultFunction = useCallback(
		(result, error) => {
			// ... existing scan logic ...
			if (scannedText) {
				setQrCodeData(scannedText);
				setIsScanning(false);
				setCheckingPunchCardStatus(true);

				// Stop all video tracks using ref
				if (mediaStreamRef.current) {
					mediaStreamRef.current.getTracks().forEach(track => track.stop());
					mediaStreamRef.current = null;
				}
			}
		},
		[qrCodeData, handleError]
	);

	// Update reset to use ref
	const reset = useCallback(() => {
		setQrCodeData("");
		setIsScanning(false);
		setCheckingPunchCardStatus(false);
		setScanResult(null);
		
		// Ensure media tracks are stopped using ref
		if (mediaStreamRef.current) {
			mediaStreamRef.current.getTracks().forEach(track => track.stop());
			mediaStreamRef.current = null;
		}
	}, []);
}
```

Benefits of this approach:
1. Avoids unnecessary re-renders when the MediaStream changes
2. Ensures we always have the latest reference during cleanup
3. Simplifies dependency arrays in useCallback hooks
4. More accurately represents that the MediaStream is a mutable external resource, not UI state

---


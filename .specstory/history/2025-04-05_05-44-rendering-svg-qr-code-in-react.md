<!-- Generated by SpecStory -->

# Rendering SVG QR Code in React (2025-04-05 00:44:54)

_**User**_

The qrCodeUrl on the @Restaurant is an svg data url so we need a way to render that on the DOM or turn it into a React component. Reference @qr-code.mdc 

---

_**Assistant**_



---

To render an SVG data URL in React, I'll create a component that can either render it inline or as an image element. Here's how to implement it:

```typescript
import React from 'react'

interface SVGRendererProps {
  dataUrl: string | null
  alt?: string
  width?: number | string
  height?: number | string
  className?: string
  renderAsImg?: boolean
}

export const SVGRenderer: React.FC<SVGRendererProps> = ({
  dataUrl,
  alt = 'QR Code',
  width = 200,
  height = 200,
  className = '',
  renderAsImg = false,
}) => {
  if (!dataUrl) return null

  // Option 1: Render as img element (safer, works in all browsers)
  if (renderAsImg) {
    return (
      <img
        src={dataUrl}
        alt={alt}
        width={width}
        height={height}
        className={className}
      />
    )
  }

  // Option 2: Extract and render inline SVG (preserves SVG features)
  try {
    // For data URLs that start with "data:image/svg+xml;base64,"
    if (dataUrl.startsWith('data:image/svg+xml;base64,')) {
      const base64Data = dataUrl.split(',')[1]
      const decodedSvg = atob(base64Data)
      return (
        <div
          className={className}
          style={{ width, height }}
          dangerouslySetInnerHTML={{ __html: decodedSvg }}
        />
      )
    }
    
    // For data URLs that start with "data:image/svg+xml;charset=utf-8,"
    if (dataUrl.startsWith('data:image/svg+xml;charset=utf-8,')) {
      const svgData = decodeURIComponent(dataUrl.split(',')[1])
      return (
        <div
          className={className}
          style={{ width, height }}
          dangerouslySetInnerHTML={{ __html: svgData }}
        />
      )
    }
    
    // Fallback to img for other formats
    return (
      <img
        src={dataUrl}
        alt={alt}
        width={width}
        height={height}
        className={className}
      />
    )
  } catch (error) {
    console.error('Error rendering SVG:', error)
    // Fallback to img if inline rendering fails
    return (
      <img
        src={dataUrl}
        alt={alt}
        width={width}
        height={height}
        className={className}
      />
    )
  }
}
```

You can use this component in your code like this:

```tsx
import { SVGRenderer } from '@/components/svg-renderer'

// Inside your component
return (
  <div>
    <SVGRenderer 
      dataUrl={restaurant.qrCodeUrl} 
      alt={`QR code for ${restaurant.name}`}
      width={200}
      height={200}
      className="bg-white p-2 rounded"
    />
  </div>
)
```

This component handles both base64-encoded SVGs and URL-encoded SVGs, with a fallback to rendering as an img tag if the extraction fails or for better compatibility.

---

_**User**_

Ok go ahead and create that

---

_**Assistant**_



---

I'll create the SVGRenderer component in a new file:

---

```diff
- 
+ import type React from 'react'
+ 
+ interface SVGRendererProps {
+   dataUrl: string | null
+   alt?: string
+   width?: number | string
+   height?: number | string
+   className?: string
+   renderAsImg?: boolean
+ }
+ 
+ export const SVGRenderer: React.FC<SVGRendererProps> = ({
+   dataUrl,
+   alt = 'QR Code',
+   width = 200,
+   height = 200,
+   className = '',
+   renderAsImg = false,
+ }) => {
+   if (!dataUrl) return null
+ 
+   // Option 1: Render as img element (safer, works in all browsers)
+   if (renderAsImg) {
+     return (
+       <img
+         src={dataUrl}
+         alt={alt}
+         width={width}
+         height={height}
+         className={className}
+       />
+     )
+   }
+ 
+   // Option 2: Extract and render inline SVG (preserves SVG features)
+   try {
+     // For data URLs that start with "data:image/svg+xml;base64,"
+     if (dataUrl.startsWith('data:image/svg+xml;base64,')) {
+       const base64Data = dataUrl.split(',')[1]
+       const decodedSvg = atob(base64Data)
+       return (
+         <div
+           className={className}
+           style={{width, height}}
+           dangerouslySetInnerHTML={{__html: decodedSvg}}
+         />
+       )
+     }
+ 
+     // For data URLs that start with "data:image/svg+xml;charset=utf-8,"
+     if (dataUrl.startsWith('data:image/svg+xml;charset=utf-8,')) {
+       const svgData = decodeURIComponent(dataUrl.split(',')[1])
+       return (
+         <div
+           className={className}
+           style={{width, height}}
+           dangerouslySetInnerHTML={{__html: svgData}}
+         />
+       )
+     }
+ 
+     // Fallback to img for other formats
+     return (
+       <img
+         src={dataUrl}
+         alt={alt}
+         width={width}
+         height={height}
+         className={className}
+       />
+     )
+   } catch (error) {
+     console.error('Error rendering SVG:', error)
+     // Fallback to img if inline rendering fails
+     return (
+       <img
+         src={dataUrl}
+         alt={alt}
+         width={width}
+         height={height}
+         className={className}
+       />
+     )
+   }
+ }
+ 
```

---

The component has been created successfully at `src/components/ui/svg-renderer.tsx`. There are some linter warnings about using `dangerouslySetInnerHTML`, but these are acceptable in this case since we're specifically trying to render SVG content from data URLs.

Now you can use this component to render your QR codes from the data URLs stored in your Restaurant objects. Here's an example of how to use it:

```tsx
import { SVGRenderer } from '@/components/ui/svg-renderer'

// Inside your component
<SVGRenderer 
  dataUrl={restaurant.qrCodeUrl} 
  alt={`QR code for ${restaurant.name}`}
  width={200}
  height={200}
  className="bg-white p-2 rounded"
/>
```

The component provides two rendering options:
1. Default (inline SVG): Preserves all SVG features and animations
2. Image mode (set `renderAsImg={true}`): More compatible across browsers

It also handles different SVG data URL formats (base64 and URL-encoded) with proper fallbacks.

---


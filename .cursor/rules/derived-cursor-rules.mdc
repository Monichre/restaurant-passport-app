---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

This document defines the rules and guidelines for the AI coding assistant. It covers project standards, tech stack, workflow, and best practices. All generated code must adhere to these rules.

## TECH STACK

-   Next.js
-   React
-   TypeScript
-   Tailwind CSS
-   Supabase
-   Drizzle ORM
-   Lucide React
-   Framer Motion
-   canvas-confetti
-   zod
-   bun
-   `@yudiel/react-qr-scanner`

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-   Use `@` to reference components, files, or data structures (e.g., `@AdminDashboardPage()`, `@useRaffleEntriesSubscription.tsx`, `@models`).
-   When referring to a UI element, use the format `@ComponentName`.
-   When referring to a file, use the format `@filename.ext`.
-   When referring to a function or data structure, use the format `@functionName` or `@dataStructureName`.

## UI DESIGN & COMPONENTS

-   When creating UI, use loading states, error states, and empty states to provide a polished user experience.
-   When displaying lists of data, use responsive grid layouts.
-   When displaying key information, use cards.
-   When displaying data in a tabular format, use the ui/table component.
-   Ensure components are well-structured and maintainable.
-   Increase contrast between dashboard components using borders and background colors to clearly distinguish sections.
-   When addressing UI change requests:
    - Analyze the request to understand the user's goal.
    - Identify the affected element(s) using the provided URL and selected elements.
    - Understand the context of the element within the page structure.
    - Pay attention to styling inconsistencies, such as absolute positioning, background gradients, and typography.
    - Propose concise fixes, focusing on removing conflicting styles and applying consistent styling from similar elements (e.g., the "hero div").
    - Remove `absolute inset-0` unless an overlay is explicitly required.
    - Remove any background gradient classes (e.g., `bg-gradient-to-*`, `from-*`, `to-*`) unless explicitly requested.
    - Apply the same typography classes as semantically similar elements (e.g., hero div) (e.g., `text-4xl font-bold text-gray-900`).
    - Ensure elements are positioned and styled consistently with the overall design.

## DATA FETCHING & API

-   Use Drizzle ORM for database interactions.
-   Use server actions for data mutations.
-   When fetching data, handle loading states, error states, and empty states.
-   When creating API endpoints, implement proper error handling.
-   When fetching data for a specific user, filter the data by user ID.
-   When real-time updates are required, use Supabase subscriptions.

## AUTHENTICATION & AUTHORIZATION

-   (Deprecated) Authentication and authorization checks are no longer required for raffle entries API routes.
-   When a new user is created, update the Clerk user's metadata with the Supabase user ID. Use `privateMetadata` to store this sensitive linking information, as it should only be accessible from the backend.
    -   After creating a user in Supabase, update the corresponding Clerk user's `privateMetadata` with the Supabase user ID. This allows linking Clerk users to their database records.
    -   Access the Supabase user ID from `user.privateMetadata.supabaseUserId` on the backend.
    -   Ensure the bigint user ID is converted to a string for metadata storage.

## DEBUGGING

-   Use `console.log` statements to debug code.
-   Inspect network requests in the browser's developer tools to debug API calls.
-   Inspect React component state using React Developer Tools.

## WORKFLOW & RELEASE RULES

-   Create a pull request for each new feature or bug fix.
-   Get code reviewed before merging.
-   Run tests before deploying.
-   Use SpecStory to generate documentation.

## NAMING CONVENTIONS

-   Use descriptive names for variables and functions.
-   Use consistent naming conventions throughout the project.
-   For subscription hooks, use the format `use[ComponentName]Subscription`. If singular is more appropriate, use that. Example: `useRestaurantSubscription` instead of `useRestaurantsSubscription`.

## ERROR HANDLING

-   Handle errors gracefully.
-   Display user-friendly error messages.
-   Log errors to the console.

## CODE ORGANIZATION

-   Keep components small and focused.
-   Use a modular code structure.
-   Separate UI components from business logic.

## DATABASE INTERACTIONS

-   Use Drizzle ORM for all database interactions.
-   Create CRUD functions for each database model.
-   Use Supabase for real-time subscriptions.

## STATE MANAGEMENT

-   Use React's `useState` hook for local component state.
-   Use React Context for global state.
-   Use refs for values that should not trigger re-renders.

## ANIMATIONS

-   Use Framer Motion for animations.
-   Use canvas-confetti for confetti animations.

## IMAGE HANDLING

-   Configure Next.js Image component for external image sources.
-   Use Next.js Image component for optimized image loading.
-   The `domains` array in `next.config.js` should contain just the hostname portion, without protocols or trailing slashes.

## TABLE DISPLAY

-   When using tables, ensure that `<td>` elements are direct children of `<tr>` elements. Avoid nesting `<td>` elements inside `<div>` elements.
-   Use `motion(TableRow)` to animate table rows. The animation properties should be directly on the table row component.
-   Ensure pagination state is properly preserved when data updates.
-   Use explicit state management for pagination to avoid unexpected resets.

## DEVELOPMENT TOOLING

-   Use Stagewise dev-tool for AI-powered editing capabilities in development.
-   Install the `@stagewise/toolbar-next` package for Next.js projects.
-   Create a `StagewiseDevToolbar` component that only renders in `development` mode.
-   Include `<StagewiseDevToolbar />` in `src/app/layout.tsx`.
-   Ensure the Stagewise toolbar is not included in production builds.

## QR CODE SCAN FUNCTIONALITY

-   When implementing QR code scan functionality, consider the following user journeys:
    - Authenticated user scans to action.
    - Unauthenticated user scans QR code generated by authenticated user for referral.
    - Unregistered user scans a QR code at a participating restaurant to join the app.
-   For unauthenticated referral flow:
    - Ensure cross-platform detection across various QR readers.
    - Redirect to web application signup page.
    - Maintain scan context through the signup process using a temporary token/ID system.
    - Implement security considerations for state management, including token expiration.
    - Trigger badge fulfillment on successful account creation.
    - Reconcile data between scan and new account.
-   Address architectural considerations including:
    - URL structure and parameter handling.
    - Cross-platform compatibility.
    - Error handling and edge cases.
    - Analytics and tracking requirements.
    - Database schema implications.
-   When generating QR codes for referrals:
    - Encode the referral URL with `referrerId`, `restaurantId` (optional), and a secure, time-limited `token`. Example: `/referral?referrerId=<userId>&restaurantId=<restaurantId>&token=<secureToken>`.
    - Generate tokens using JWT or random UUID, storing them in the `referral_tokens` table with metadata and expiration.
    - Create a backend endpoint `POST /api/referrals/generate` that accepts `{ referrerId, restaurantId }` and returns `{ url, token, expiresAt }`.
-   When an unauthenticated user scans a referral QR code:
    - The `/referral` route should detect the unauthenticated user and prompt them to sign up with a message like: "Sign up to claim your reward from <referrer/restaurant>!".
    - Store the referral token and parameters in session/localStorage for multi-step signup or in the Next.js server session.
    - Use a `referral_tokens` table with fields: `{ token, referrerId, restaurantId, createdAt, expiresAt, claimedByUserId, status }`. Mark the token as "claimed" after signup.
-   On signup completion:
    - Create a backend endpoint `POST /api/referrals/claim` that accepts `{ token, newUserId }`.
    - Validate the token and mark the referral as claimed.
    - Award the "First Restaurant" badge or points to the new user and optionally reward the referrer.
    - Link the referral record to the new user and log the conversion.
-   Implement the following security measures:
    - Use JWT (signed, expiring) or random UUID (stored in DB) for tokens.
    - Expire tokens after a short period (e.g., 24h).
    - Mark tokens as claimed after use.
    - Validate all parameters server-side.
    - Log all actions for audit/analytics.
-   Implement the following error handling:
    - Show an error and prompt to sign up without reward for invalid/expired tokens.
    - Inform the user and allow normal signup if the token is already claimed.
    - Show a generic error for missing parameters.
    - Ensure tokens remain unclaimed until expiration if signup is abandoned.
-   Implement analytics and tracking for:
    - QR code generation (who, when, where).
    - Scan events (IP, device, timestamp).
    - Signup completions (conversion rate).
    - Badge/point fulfillment.
-   The `referral_tokens` table should have the following structure:
    ```typescript
    export const referralTokens = pgTable("referral_tokens", {
      id: serial("id").primaryKey(),
      token: text("token").notNull().unique(),
      referrerId: integer("referrer_id").references(() => users.id),
      restaurantId: integer("restaurant_id").references(() => restaurants.id),
      createdAt: timestamp("created_at").defaultNow(),
      expiresAt: timestamp("expires_at"),
      claimedByUserId: integer("claimed_by_user_id").references(() => users.id),
      status: text("status").notNull().default("active"), // active, claimed, expired
    });
    ```
-   Implement the following API endpoints:
    - `POST /api/referrals/generate` – Authenticated, returns referral URL/token.
    - `GET /api/referrals/validate?token=...` – Validates token (for landing page).
    - `POST /api/referrals/claim` – On signup, claims reward.
-   **Public QR Onboarding Flow:**
    - **Scenario:** A non-app-user (stranger/guest) scans a QR code displayed at a participating restaurant. The system should:
        - Recognize the scan as coming from a public QR code (not a referral or user-generated code).
        - Guide the user to sign up for the app, preserving the context of which restaurant’s QR code was scanned.
        - Upon signup, award the "First Restaurant" badge or points.
    - **Step-by-Step Implementation Plan:**
        - **1. QR Code Generation & Placement**
            - **What Data Should Be Encoded?**
                - **URL format:**  
                  `https://app.example.com/qr?restaurantId=<restaurantId>&campaign=<optional>`
                    - `restaurantId`: Unique identifier for the restaurant.
                    - `campaign`: (Optional) For tracking special promotions.
            - **How to Generate?**
                - **Admin dashboard**: Restaurant admins or system admins generate QR codes for each location.
                - **Backend endpoint**:  
                  - `GET /api/qr/generate?restaurantId=...`
                  - Returns a QR code image (PNG/SVG) encoding the above URL.
                - **Physical placement**: Print and place QR codes on tables, menus, posters, etc.
        - **2. Scan by Unregistered User**
            - **Cross-Platform Detection**
                - Any QR reader (native camera, 3rd party app) opens the encoded URL in a browser.
            - **Landing Page Logic**
                - **Route:** `/qr` (Next.js page)
                - **Behavior:**
                    - If user is **not authenticated**:
                        - Show a branded landing page:  
                          “Welcome to [App Name]! You scanned a code at [Restaurant Name]. Sign up to start earning rewards.”
                        - Prominent **Sign Up** and **Sign In** buttons.
                        - Store `restaurantId` (and `campaign` if present) in localStorage, session, or as a query param for the signup flow.
                    - If user is **already authenticated**:
                        - Optionally, redirect to punch card for that restaurant or show a “Welcome back!” message.
        - **3. State Preservation Through Signup**
            - **How to Maintain Context?**
                - **Store `restaurantId` and `campaign`**:
                    - In localStorage/sessionStorage (client-side)
                    - Or as a query param passed through the signup flow
                - **Signup flow** (Clerk or custom):
                    - On successful signup, check for stored `restaurantId`/`campaign` context.
            - **Security Considerations**
                - No sensitive data in QR or URL.
                - Validate `restaurantId` on backend before granting rewards.
                - Optionally, set a short-lived cookie or session value for extra robustness.
        - **4. Signup Completion & Reward**
            - **On Account Creation**
                - **Backend logic** (triggered post-signup):
                    - Check for `restaurantId` context.
                    - Award “First Visit” badge, points, or other onboarding reward.
                    - Optionally, create a punch card for the restaurant.
                    - Log the event for analytics (user, restaurant, campaign, timestamp).
            - **Data Reconciliation**
                - Link the new user to the restaurant for analytics.
                - Optionally, send a welcome notification or email.
    - **Technical Requirements & Specifications**
        - **A. URL Structure & Parameter Handling**
            - `/qr?restaurantId=123&campaign=spring2024`
            - All params validated server-side.
            - Use Next.js dynamic route: `/app/qr/page.tsx`
        - **B. Token Expiration & Security**
            - No sensitive tokens needed; only public IDs.
            - Validate `restaurantId` exists and is active.
            - Prevent abuse (e.g., rate limit badge/point grants per user).
        - **C. Cross-Platform Compatibility**
            - QR code encodes HTTPS URL.
            - Works with any QR reader/camera.
            - Mobile-first, responsive landing page.
        - **D. Error Handling & Edge Cases**
            - **Invalid/missing `restaurantId`**: Show error, allow generic signup.
            - **Already signed up user scans**: Show punch card or “already a member” message.
            - **Signup abandoned**: No reward granted until signup completes.
        - **E. Analytics & Tracking**
            - Log:
                - QR code scans (IP, device, timestamp, restaurant, campaign)
                - Signups from QR flow (conversion rate)
                - Badge/point fulfillment
            - Use for campaign effectiveness, restaurant engagement, etc.
        - **F. Database Schema Implications**
            - **No new tables required** (unless you want to track scans separately).  
            - Optionally, add a `qr_signup_source` or `last_qr_scan_restaurant_id` field to the `users` table for attribution.
            - Log events in an `analytics` or `qr_scan_events` table for deeper insights.
    - **API Endpoints**
        | Endpoint                       | Method | Purpose                        | Auth Required | Params/Body                |
        |------------------------------- |--------|------------------------------- | 구분 | 구분 |
        | `/api/qr/generate`             | GET    | Generate QR code for restaurant| Yes (admin)  | `restaurantId`, `campaign`|
        | `/api/qr/scan`                 | POST   | Log scan event                 | No           | `{restaurantId, campaign, deviceInfo}`|
        | `/api/qr/signup-complete`      | POST   | Award badge/points post-signup | Yes (new user)| `{restaurantId, campaign}`|
    - **Data Flow Diagram**
        ```mermaid
        sequenceDiagram
            participant Guest as Unregistered User
            participant QR as QR Code
            participant App as Web App
            participant API as Backend API
            participant DB as Database

            Guest->>QR: Scans QR code
            QR-->>App: Opens /qr?restaurantId=123
            App->>API: POST /api/qr/scan (log event)
            App->>Guest: Shows signup prompt (with restaurant context)
            Guest->>App: Completes signup
            App->>API: POST /api/qr/signup-complete
            API->>DB: Award badge/points, create punch card
            App->>Guest: Shows welcome/reward
        ```
    - **Summary Table: Key Endpoints & Data**
        | Endpoint                       | Method | Purpose                        | Auth Required | Params/Body                |
        |------------------------------- |--------|------------------------------- | 구분 | 구분 |
        | `/api/qr/generate`             | GET    | Generate QR code for restaurant| Yes (admin)  | `restaurantId`, `campaign`|
        | `/api/qr/scan`                 | POST   | Log scan event                 | No           | `{restaurantId, campaign, deviceInfo}`|
        | `/api/qr/signup-complete`      | POST   | Award badge/points post-signup | Yes (new user)| `{restaurantId, campaign}`|
    - **Security & Best Practices**
        - No sensitive data in QR/URL.
        - Validate all params server-side.
        - Prevent duplicate rewards for same user/restaurant.
        - Log all actions for analytics.
    - **Edge Cases & Error Handling**
        - Invalid/missing `restaurantId`: Show error, allow generic signup.
        - Already registered user: Show punch card or “already a member” message.
        - Multiple signups from same device: Prevent abuse.
    - **Analytics & Tracking**
        - Track scans, signups, reward fulfillment.
        - Attribute new users to restaurants/campaigns.
    - **Database Schema Changes (Optional)**
        - Add `qr_signup_source` to `users` table.
        - Add `qr_scan_events` table for analytics.
    - **Next Steps**
        - Implement QR code generation and admin UI.
        - Build `/qr` landing page and signup flow.
        - Integrate reward logic post-signup.
        - Add analytics and error handling.

## CURSOR RULES

- Use Cursor Rules to standardize development patterns.
- Project structure includes `rules` and `features` directories within the `.cursor` directory.

## DRIZZLE ORM PATTERNS & DATABASE STANDARDS

-   **Schema Design Patterns**
    -   **Use bigserial for primary keys** with mode: "bigint"

        ```typescript
        // ✅ DO: Standard primary key pattern
        id: bigserial({ mode: "bigint" }).primaryKey().notNull(),

        // ❌ DON'T: Use regular serial or omit mode
        id: serial().primaryKey(),
        ```
    -   **Foreign key relationships** must include explicit foreignKey constraints

        ```typescript
        // ✅ DO: Explicit foreign key with proper naming
        foreignKey({
        columns: [table.userId],
        foreignColumns: [users.id],
        name: "punch_cards_user_id_users_id_fk",
        }),
        ```
    -   **Timestamp fields** should use consistent format with timezone

        ```typescript
        // ✅ DO: Standard timestamp pattern
        createdAt: timestamp("created_at", {
        withTimezone: true,
        mode: "string",
        }).defaultNow(),
        ```
-   **Model Function Patterns**
    -   **All model functions** must use "use server" directive and follow naming conventions

        ```typescript
        // ✅ DO: Standard model file structure
        "use server";

        import { eq, desc, and } from "drizzle-orm";
        import { db } from "../../db";
        import { tableName } from "@/db/drizzle/schema";

        // Get all records
        export const getTableName = async () => {
        return await db.query.tableName.findMany({
            with: { relations: true },
            orderBy: desc(tableName.createdAt),
        });
        };
        ```
    -   **CRUD operations** should include proper error handling and return types

        ```typescript
        // ✅ DO: Complete CRUD with timestamps
        export const createRecord = async (data: CreateInput) => {
        return await db
            .insert(tableName)
            .values({
            ...data,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            })
            .returning();
        };

        export const updateRecord = async (id: bigint, data: UpdateInput) => {
        return await db
            .update(tableName)
            .set({
            ...data,
            updatedAt: new Date().toISOString(),
            })
            .where(eq(tableName.id, id))
            .returning();
        };
        ```
-   **Query Patterns**
    -   **Use query builder** for complex relations and prefer `db.query` over raw SQL

        ```typescript
        // ✅ DO: Use query builder with relations
        return await db.query.punchCards.findMany({
        where: eq(punchCards.userId, userId),
        with: {
            restaurant: true,
            user: true,
        },
        });

        // ❌ DON'T: Use raw SQL unless absolutely necessary
        ```
    -   **Filtering and pagination** should use consistent patterns

        ```typescript
        // ✅ DO: Standard filtering with bigint conversion
        export const getRecordsByUserId = async (userId: bigint) => {
        return await db.query.tableName.findMany({
            where: eq(tableName.userId, userId),
            orderBy: desc(tableName.createdAt),
        });
        };
        ```
-   **Type Safety & Validation**
    -   **BigInt handling** must be consistent across all database operations

        ```typescript
        // ✅ DO: Always convert string IDs to BigInt for database operations
        const recordId = BigInt(stringId);
        const result = await getRecordById(recordId);

        // Use convertBigInts utility for API responses
        return NextResponse.json({
            success: true,
            data: convertBigInts(result),
        });
        ```
    -   **Unique constraints** should be properly defined in schema

        ```typescript
        // ✅ DO: Define unique constraints for business logic
        (table) => [
        unique("users_clerk_id_unique").on(table.clerkId),
        uniqueIndex("unique_restaurant_user_idx").using(
            "btree",
            table.userId.asc().nullsLast().op("int8_ops"),
            table.restaurantId.asc().nullsLast().op("int8_ops"),
        ),
        ]
        ```

## SEO & METADATA

-   Include the following links in the `<head>` of the HTML:
    ```html
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    ```
-   In Next.js 13+ with the app router, add favicon and manifest links through the `metadata` configuration in `app/layout.tsx`:
    ```typescript
    export const metadata = {
      icons: {
        icon: [
          { url: '/favicon-16x16.png', sizes: '16x16', type: 'image/png' },
          { url: '/favicon-32x32.png', sizes: '32x32', type: 'image/png' }],
        apple: [{ url: '/apple-touch-icon.png', sizes: '180x180', type: 'image/png' }],
      },
      manifest: '/site.webmanifest',
    };
    ```
    Ensure the corresponding favicon files are in the `public` directory.

## STORYBOOK INTEGRATION & SERVER COMPONENT HANDLING

-   **General Strategy:** When integrating Storybook, ensure client components are isolated from server components, especially those that depend on database connections. This can be achieved through mocking database interactions or excluding server components from Storybook stories.

-   **Version Consistency:** Ensure all Storybook packages have matching versions. Use `npx storybook doctor` to diagnose and resolve version mismatches.

-   **Mocking Database Interactions:**
    -   When server-side database code is imported into client components for Storybook stories, create mocks for the database interactions.
    -   This allows client components to be rendered in Storybook without relying on a live database connection.

-   **Excluding Server Components:**
    -   Identify server components that are incorrectly marked as `'use client'`.
    -   Exclude these server components from Storybook stories to prevent errors in the client environment.

-   **Specific Cases:**
    -   If a page component (e.g., `@src/app/admin/restaurants/[id]/page.tsx`) imports database models, ensure that the database interactions are mocked for Storybook.
    -   When creating stories for components like `@ProfilePage.stories.tsx`, verify that server components are not being rendered directly.

-   **Implementation Techniques:**
    -   Use Storybook's `decorators` to provide mock data or mock implementations of database functions.
    -   Employ conditional imports or dynamic imports to load mock data only when running in Storybook.

-   **Component Annotations:**
    -   Ensure that server components that perform database operations are not marked with the `'use client'` directive.

-   **Mocking Implementation Plan:**
    -   Create a mocking layer that intercepts database calls in the Storybook environment.
    -   Implement mock versions of `getPunchCardsByUserId`, `getRaffleEntriesByUserId`, and `supabaseBrowserClient` in `src/lib/storybook-mocks/database-mocks.ts` and `src/lib/storybook-mocks/supabase-mock.ts`.
    -   Create Storybook-specific hooks in `src/hooks/storybook/` that return predefined mock data and don't import database functions.
    -   Update `.storybook/main.ts` to use webpack aliases to redirect imports of database functions and hooks to the mock implementations.
    -   Create a `MockDataProvider` component in `src/lib/storybook-mocks/mock-context.tsx` to provide mock data for users, restaurants, punch cards, and raffle entries.
    -   Wrap stories in `ProfilePage.stories.tsx` with `MockDataProvider`, remove direct database mocking, and use context-provided mock data.
    -   For components that import server components, extract client components for stories, provide mocked server data, or exclude them from Storybook.

-   **Webpack Aliasing:**
    -   In the Storybook webpack config, alias `@/db/models/punch-cards`, `@/db/models/raffle-entries`, and `@/db/supabase/supabase.client` to their mock versions.
    -   Ensure mock versions export the same function signatures, return `Promise.resolve(mockData)`, and don't import actual database code.

-   **Testing:**
    -   Ensure mocks cover all database function signatures, possible return types, error conditions, loading states, and empty data states.
    -   Test that Storybook builds without errors, stories render without server imports, components work with mock data, and real components still work with real data.

-   **Version Management:**
    -   If encountering "No matching export" or SB_CORE-SERVER_0004 errors in Storybook, ensure all Storybook packages use compatible versions.
    -   Use `npx storybook doctor` to identify and resolve version mismatches.
    -   Consider downgrading all Storybook packages to the stable 8.x series (e.g., 8.6.14) if encountering compatibility issues with newer alpha or release candidate versions.
    -   When downgrading, verify compatibility of `@storybook/nextjs-vite` and `@storybook/addon-vitest` as they may not have corresponding 8.x versions. Use the latest compatible versions for your Storybook setup.

## PUNCH CARD UI ANIMATIONS

-   When implementing punch card UI, use Framer Motion for engaging and delightful animations to enhance the user experience.

-   **Card Entrance Animation:**
    -   The entire card should fade in and slide up from below.
    ```typescript
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.5 }}
    ```

-   **Latest Punch "WOW" Effect:**
    -   The newest punch should have a multi-phase animation:
        -   Scale up dramatically (1.3x).
        -   Rotate left and right.
        -   Color changes from gray → green → darker green → back to gray.
    ```typescript
    animate={
      index === currentPunches - 1
        ? {
            scale: [1, 1.3, 1.1, 1],
            rotate: [0, 10, -5, 0],
            backgroundColor: ['#ddd', '#10b981', '#059669', '#ddd']
          }
        : {}
    }
    ```

-   **Stamp Drop Animation:**
    -   Each stamp should spin in from a 180° rotation with bouncy spring physics and staggered timing for sequential reveals.
    ```typescript
    initial={{ scale: 0, opacity: 0, rotate: -180 }}
    animate={{
      scale: [0, 1.2, 1],
      opacity: [0, 1, 1],
      rotate: [-180, 10, 0]
    }}
    transition={{
      type: 'spring',
      stiffness: 400,
      damping: 25,
      delay: index === currentPunches - 1 ? 0.3 : 0,
      duration: 0.6
    }}
    ```

-   **Ripple Effect:**
    -   Use an expanding circle ripple effect on the newest punch to create a "pop" visual feedback.
    ```typescript
    <motion.div
      className='absolute inset-0 rounded-full border-2 border-primary'
      initial={{ scale: 1, opacity: 1 }}
      animate={{
        scale: [1, 2, 3],
        opacity: [1, 0.5, 0]
      }}
      transition={{ duration: 0.6, delay: 0.2 }}
    />
    ```

-   **Progress Bar Animation:**
    -   Use an animated progress bar that fills up with a delayed start for dramatic effect.
    ```typescript
    <motion.div
      className='h-full bg-green-500 rounded-full w-0'
      animate={{ width: `${percentageProgress}%` }}
      transition={{ duration: 0.5, delay: 0.5 }}
    />
    ```

## CURSOR RULES

- Use Cursor Rules to standardize development patterns.
- Project structure includes `rules` and `features` directories within the `.cursor` directory.

## DRIZZLE ORM PATTERNS & DATABASE STANDARDS

-   **Schema Design Patterns**
    -   **Use bigserial for primary keys** with mode: "bigint"

        ```typescript
        // ✅ DO: Standard primary key pattern
        id: bigserial({ mode: "bigint" }).primaryKey().notNull(),

        // ❌ DON'T: Use regular serial or omit mode
        id: serial().primaryKey(),
        ```
    -   **Foreign key relationships** must include explicit foreignKey constraints

        ```typescript
        // ✅ DO: Explicit foreign key with proper naming
        foreignKey({
        columns: [table.userId],
        foreignColumns: [users.id],
        name: "punch_cards_user_id_users_id_fk",
        }),
        ```
    -   **Timestamp fields** should use consistent format with timezone

        ```typescript
        // ✅ DO: Standard timestamp pattern
        createdAt: timestamp("created_at", {
        withTimezone: true,
        mode: "string",
        }).defaultNow(),
        ```
-   **Model Function Patterns**
    -   **All model functions** must use "use server" directive and follow naming conventions

        ```typescript
        // ✅ DO: Standard model file structure
        "use server";

        import { eq, desc, and } from "drizzle-orm";
        import { db } from "../../db";
        import { tableName } from "@/db/drizzle/schema";

        // Get all records
        export const getTableName = async () => {
        return await db.query.tableName.findMany({
            with: { relations: true },
            orderBy: desc(tableName.createdAt),
        });
        };
        ```
    -   **CRUD operations** should include proper error handling and return types

        ```typescript
        // ✅ DO: Complete CRUD with timestamps
        export const createRecord = async (data: CreateInput) => {
        return await db
            .insert(tableName)
            .values({
            ...data,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            })
            .returning();
        };

        export const updateRecord = async (id: bigint, data: UpdateInput) => {
        return await db
            .update(tableName)
            .set({
            ...data,
            updatedAt: new Date().toISOString(),
            })
            .where(eq(tableName.id, id))
            .returning();
        };
        ```
-   **Query Patterns**
    -   **Use query builder** for complex relations and prefer `db.query` over raw SQL

        ```typescript
        // ✅ DO: Use query builder with relations
        return await db.query.punchCards.findMany({
        where: eq(punchCards.userId, userId),
        with: {
            restaurant: true,
            user: true,
        },
        });

        // ❌ DON'T: Use raw SQL unless absolutely necessary
        ```
    -   **Filtering and pagination** should use consistent patterns

        ```typescript
        // ✅ DO: Standard filtering with bigint conversion
        export const getRecordsByUserId = async (userId: bigint) => {
        return await db.query.tableName.findMany({
            where: eq(tableName.userId, userId),
            orderBy: desc(tableName.createdAt),
        });
        };
        ```
-   **Type Safety & Validation**
    -   **BigInt handling** must be consistent across all database operations

        ```typescript
        // ✅ DO: Always convert string IDs to BigInt for database operations
        const recordId = BigInt(stringId);
        const result = await getRecordById(recordId);

        // Use convertBigInts utility for API responses
        return NextResponse.json({
            success: true,
            data: convertBigInts(result),
        });
        ```
    -   **Unique constraints** should be properly defined in schema

        ```typescript
        // ✅ DO: Define unique constraints for business logic
        (table) => [
        unique("users_clerk_id_unique").on(table.clerkId),
        uniqueIndex("unique_restaurant_user_idx").using(
            "btree",
            table